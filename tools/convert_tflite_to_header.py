#!/usr/bin/env python3
"""
Convert TFLite model to C header file for embedding in ESP32 firmware.

This tool converts a quantized TFLite model into a C header file that
can be embedded directly in the ESP32 firmware, avoiding the need for
separate file system access.

Usage:
    python3 convert_tflite_to_header.py model.tflite output.h

The output will be a header file with:
- Model data as a byte array
- Model size constant
- Include guards for C/C++
"""

import sys
import argparse
from pathlib import Path


def convert_tflite_to_header(tflite_path, output_path, array_name='g_model_data'):
    """
    Convert TFLite model to C header file.

    Args:
        tflite_path: Path to .tflite file
        output_path: Path to output .h file
        array_name: Name for the byte array (default: g_model_data)
    """
    tflite_path = Path(tflite_path)
    output_path = Path(output_path)

    if not tflite_path.exists():
        print(f"Error: TFLite file not found: {tflite_path}")
        return False

    # Read the TFLite model
    print(f"Reading TFLite model from {tflite_path}...")
    with open(tflite_path, 'rb') as f:
        model_data = f.read()

    model_size = len(model_data)
    print(f"Model size: {model_size} bytes ({model_size / 1024:.1f} KB)")

    # Generate C header
    print(f"Writing C header to {output_path}...")

    # Create header guard from filename
    guard_name = output_path.stem.upper().replace('-', '_').replace('.', '_') + '_H'

    with open(output_path, 'w') as f:
        # Header guard
        f.write(f"#ifndef {guard_name}\n")
        f.write(f"#define {guard_name}\n\n")

        # Add documentation
        f.write("/**\n")
        f.write(f" * @file {output_path.name}\n")
        f.write(" * @brief TFLite model data converted from .tflite file\n")
        f.write(" *\n")
        f.write(f" * Model: {tflite_path.name}\n")
        f.write(f" * Size: {model_size} bytes\n")
        f.write(f" * Source: {tflite_path}\n")
        f.write(" *\n")
        f.write(" * Auto-generated by convert_tflite_to_header.py\n")
        f.write(" * Do not edit manually\n")
        f.write(" */\n\n")

        # Include C++ guard
        f.write("#ifdef __cplusplus\n")
        f.write("extern \"C\" {\n")
        f.write("#endif\n\n")

        # Write model data as hex array
        f.write(f"#include <stdint.h>\n\n")
        f.write(f"// TFLite model data ({model_size} bytes)\n")
        f.write(f"const uint8_t {array_name}[] = {{\n")

        # Write bytes in rows of 12
        for i in range(0, model_size, 12):
            chunk = model_data[i:i+12]
            hex_bytes = ', '.join(f'0x{b:02x}' for b in chunk)
            f.write(f"    {hex_bytes}")
            if i + 12 < model_size:
                f.write(',')
            f.write('\n')

        f.write("};\n\n")

        # Size constant
        size_name = array_name.replace('g_', '').replace('_data', '_len')
        f.write(f"const unsigned int {size_name} = {model_size};\n\n")

        # End C++ guard
        f.write("#ifdef __cplusplus\n")
        f.write("}\n")
        f.write("#endif\n\n")

        # End header guard
        f.write(f"#endif // {guard_name}\n")

    print(f"âœ“ Successfully converted model to {output_path}")
    print(f"  Array name: {array_name}")
    print(f"  Size constant: {size_name}")
    print(f"  Model size: {model_size} bytes")

    return True


def main():
    parser = argparse.ArgumentParser(
        description='Convert TFLite model to C header for ESP32 embedding',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic usage
  python3 convert_tflite_to_header.py model.tflite model_data.h

  # Custom array name
  python3 convert_tflite_to_header.py model.tflite model_data.h --array-name my_model

  # Convert to firmware directory
  python3 convert_tflite_to_header.py pose_model_quant.tflite ../firmware/main/model_data.h

Integration in firmware:
  #include "model_data.h"

  // Model is now available as:
  // extern const uint8_t g_model_data[];
  // extern const unsigned int model_len;

  tflite::Model* model = tflite::GetModel(g_model_data);
        """
    )

    parser.add_argument('tflite', help='Input TFLite model file (.tflite)')
    parser.add_argument('output', help='Output C header file (.h)')
    parser.add_argument('--array-name', default='g_model_data',
                       help='Name for the byte array (default: g_model_data)')

    args = parser.parse_args()

    # Convert the model
    success = convert_tflite_to_header(
        args.tflite,
        args.output,
        args.array_name
    )

    if not success:
        sys.exit(1)

    print("\nNext steps:")
    print("1. Copy the header to your firmware directory:")
    print(f"   cp {args.output} firmware/main/")
    print("2. Include in your source file:")
    print(f"   #include \"{Path(args.output).name}\"")
    print("3. Use in TFLite initialization:")
    print("   const tflite::Model* model = tflite::GetModel(g_model_data);")


if __name__ == '__main__':
    main()
